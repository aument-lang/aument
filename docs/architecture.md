# aulang's architecture

This document is intended to show a bird-eye's view of aulang's implementation (also named aulang, I'm bad at naming things). This document describes how aulang's internals interact with each-other in general. If you need specifics, please check out the source code :)

In this documentation, *aulang* refers specifically this C program, the aulang language's implementation.

## From source file to destination

*aka* **What happens when you run/build a file in aulang?**

### Command line parsing

First, aulang parses arguments passed in the command line. Command line arguments passed to aulang specifies *What action does aulang take? What else should aulang do?*

The syntax of valid command line arguments is described in [Command line options](./cmdline.md). Argument parsing is implemented in the `main` function (`src/main.c`).

### Parsing the file

If the user wants aulang to interpret or build a source file, aulang first has to parse it. It does this in the following order:

  1. **Load the file into memory:** For systems that support it, the file is mapped through the `mmap` call, or else it falls back to using the C functions `fopen`, `fread` and `fclose` to emulate it. aulang represents a file in memory through the `au_mmap_info` object. 
  2. **Parse the file:**
    * The parsing process transforms **source** into **lexer tokens** and finally outputs **bytecode** directly into a structure representing an *aulang program* (the `au_program` object).
    * aulang uses a simple recursive descent parser: a parser starts by calling a main `parser_exec` function, which in turn calls other "grammar" function (functions which implement specific bits of grammar)
    * The parser has an extra *lexer* component, it turns source bytes into tokens on the fly.
    * These "grammar" functions receive input tokens from the *lexer* and writes bytecode into the program.
  3. **Finalizing an aulang program:** finally, aulang stores relavant information about the path of the program into the `au_program` struct. The path information is useful for module loading.

If at any point the parsing stage fails, aulang prints out a nice error message telling the user what the parser error is and where did it occured.

### `run` command: interpret the file

Once the `au_program` struct is built, we're ready to run it in a virtual machine.

#### Thread safety first!

For each thread that a virtual machine is run, it needs a thread-local `au_vm_thread_local` object in order to store thread-local constants or imported module data.

The `au_vm_thread_local` object should always be allocated within that thread's stack.

#### Executing the program

After setting up everything required, the virtual machine is called. It runs any bytecode generated in the parsing process.

If at any point the virtual machine unrecoverably panics, the program will abort through the `abort` C function.

### `build` command: builds the file

If aulang is asked to build a source file, it will generate a standalone C source in memory from the bytecode generated by the parser.

Once finished, the C source is written to a temporary file, and aulang invokes the C compiler (`gcc` or anything specified by the `CC` enviornment variable).



## Data structures

## Virtual machine details

This section describes the various components of the virtual machine.

### The VM itself

aulang's virtual machine is a register machine with 256 registers and 256 maximum local variables. These registers and local variables are specific to a function call and are stored on a virtual stack frame.

The virtual machine also contains an argument stack, it is used to passed arguments in function calls. Every function call inside a virtual machine is represented by a real function call (i.e. a C function call).

See the function `au_vm_exec_unverified` for more details.

### The bytecode

A program in the VM is represented by bytecode. Bytecode in aulang's VM is a flat array containing 32-bit operations, which generally has the following form:

```
[ code (1 byte) ] [ code-specific data (3 byte) ]
```

Where the `code` byte tells the virtual machine what operation to do (add, subtract, call a function, ...).

#### `OP_EXIT`

Causes the virtual machine to return none.

#### `OP_NOP`

Does nothing.

#### Constant data opcodes

##### `OP_MOV_U16`

**Structure:**

```
[ code (1 byte) ] [ reg (1 byte) ] [ n (2 bytes) ]
```

Moves the integer specified by the 16-bit number (with endianness specified by the running platform) `n` into register `reg`.

##### `OP_MOV_BOOL`

**Structure:**

```
[ code (1 byte) ] [ n (1 byte) ] [ reg (1 bytes) ] [ (unused 1 byte) ]
```

Moves the boolean specified by the 8-bit number `n` into register `reg`.

##### `OP_LOAD_CONST`

**Structure:**

```
[ code (1 byte) ] [ reg (1 byte) ] [ n (2 bytes) ]
```

Moves the constant specified by the 16-bit number (with endianness specified by the running platform) `n` into register `reg`.

#### Binary opcodes

These are the opcodes `OP_MUL`, `OP_DIV`, `OP_ADD`, `OP_SUB`, `OP_MOD`, `OP_EQ`, `OP_NEQ`, `OP_LT`, `OP_GT`, `OP_LEQ`, `OP_GEQ`. They have the following structure:

```
[ code (1 byte) ] [ left (1 byte) ] [ right (1 byte) ] [ result (1 byte) ]
```

They perform a binary operation specified by `code` on the registers specified by `left` and `right`, and stores the result into the register specified by `result`.

##### Binary-assign opcodes

These are the opcodes `OP_MUL_ASG`, `OP_DIV_ASG`, `OP_ADD_ASG`, `OP_SUB_ASG`, `OP_MOD_ASG`. They have the following structure:

```
[ code (1 byte) ] [ reg (1 byte) ] [ local (1 byte) ] [ (unused 1 byte) ]
```

They perform a binary operation specified by `code` on the local variable specified by `local` and register specified by `reg`, and stores the result into the local variable.

#### Unary opcodes

These are the opcodes `OP_NOT`. They have the following structure:

```
[ code (1 byte) ] [ reg (1 byte) ] [ (unused 2 bytes) ]
```

They perform the unary operation specified by `code` directly on the register specified by `reg`.

#### `OP_MOV_REG_LOCAL` and `OP_MOV_LOCAL_REG`

#### `OP_PRINT`

#### Jump opcodes

##### `OP_JIF` and `OP_JNIF`

##### `OP_JREL` and `OP_JRELB`

#### Function-related opcodes

##### `OP_PUSH_ARG`

##### `OP_CALL`

##### `OP_RET_LOCAL`, `OP_RET`, `OP_RET_NULL`

#### Array-related opcodes

##### `OP_ARRAY_NEW`

##### `OP_ARRAY_PUSH`

##### `OP_IDX_GET`

##### `OP_IDX_SET`

### Function calls 

### Module imports and exports

In interpreter mode, aulang imports files in runtime rather than parsing time. Imported modules are referenced as indices to an imported file array, internal to the **importer**. We'll call the imported module's index relative to the *importer*, the *relative module index*.

When a file is parsed, if it calls an external module's function, the parser records it as a "virtual function". The virtual function is an object which has a name, the number of arguments it takes and the *relative module index* of the module. This *virtual function* is blank, it doesn't know which external function it points to, only what the external function is named and what it looks like.

On runtime, when the virtual machine imports the module, it will store a reference to the module in the `au_vm_thread_local` object. The *relative module index* of the imported module is used to store pointers to the corresponding actual module function, into the virtual function that refers to it.

## C compiler details
