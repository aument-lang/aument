# aulang's architecture

This document is intended to show a bird-eye's view of aulang's implementation (also named aulang, I'm bad at naming things). This document describes how aulang's internals interact with each-other in general. If you need specifics, please check out the source code :)

In this documentation, *aulang* refers specifically this C program, the aulang language's implementation.

## From source file to destination

*aka* **What happens when you run/build a file in aulang?**

### Command line parsing

First, aulang parses arguments passed in the command line. Command line arguments passed to aulang specifies *What action does aulang take? What else should aulang do?*

The syntax of valid command line arguments is described in [Command line options](./cmdline.md). Argument parsing is implemented in the `main` function (`src/main.c`).

### Parsing the file

If the user wants aulang to interpret or build a source file, aulang first has to parse it. It does this in the following order:

  1. **Load the file into memory:** For systems that support it, the file is mapped through the `mmap` call, or else it falls back to using the C functions `fopen`, `fread` and `fclose` to emulate it. aulang represents a file in memory through the `au_mmap_info` object. 
  2. **Parse the file:**
    * The parsing process transforms **source** into **lexer tokens** and finally outputs **bytecode** directly into a structure representing an *aulang program* (the `au_program` object).
    * aulang uses a simple recursive descent parser: a parser starts by calling a main `parser_exec` function, which in turn calls other "grammar" function (functions which implement specific bits of grammar)
    * The parser has an extra *lexer* component, it turns source bytes into tokens on the fly.
    * These "grammar" functions receive input tokens from the *lexer* and writes bytecode into the program.
  3. **Finalizing an aulang program:** finally, aulang stores relavant information about the path of the program into the `au_program` struct. The path information is useful for module loading.

If at any point the parsing stage fails, aulang prints out a nice error message telling the user what the parser error is and where did it occured.

### `run` command: interpret the file

Once the `au_program` struct is built, we're ready to run it in a virtual machine.

#### Thread safety first!

For each thread that a virtual machine is run, it needs a thread-local `au_vm_thread_local` object in order to store thread-local constants or imported module data.

The `au_vm_thread_local` object should always be allocated within that thread's stack.

#### Executing the program

After setting up everything required, the virtual machine is called. It runs any bytecode generated in the parsing process, starting with the top-level main function.

If at any point the virtual machine unrecoverably panics, the program will abort through the `abort` C function.

### `build` command: builds the file

If aulang is asked to build a source file, it will generate a standalone C source in memory from the bytecode generated by the parser.

Once finished, the C source is written to a temporary file, and aulang invokes the C compiler (`gcc` or anything specified by the `CC` environment variable).

## Data structures

### Values

Everything that can be represented in the aulang language is a **value**. In the implementation, a value is a structure which holds type and data information. On platforms that support it, values are represented as 64-bit floating point numbers, with non-float values represented as *not-a-number* through NaN tagging.

## Virtual machine details

This section describes the various components of the virtual machine.

### The VM itself

aulang's virtual machine is a register machine with 256 registers and 256 maximum local variables. These registers and local variables are specific to a function call and are stored on a virtual stack frame.

The virtual machine also contains an argument stack, it is used to passed arguments in function calls. Every function call inside a virtual machine is represented by a real function call (i.e. a C function call).

See the function `au_vm_exec_unverified` for more details.

### Bytecode

A program in the VM is represented by bytecode. Bytecode in aulang's VM is a flat byte array containing 32-bit operations, which has the following form:

```
[ code (1 byte) ] [ code-specific data (3 byte) ]
```

Where the `code` byte tells the virtual machine what operation to do (add, subtract, call a function, ...).

Like a real machine, aulang's VM has a program counter, it starts at zero and it points to the current instruction being processed. The program counter counts in **bytes**, not 32-bit values.

#### `OP_EXIT`

Causes the virtual machine to return none.

#### `OP_NOP`

Does nothing.

#### Constant data opcodes

##### `OP_MOV_U16`

**Structure:**

```
[ code (1 byte) ] [ reg (1 byte) ] [ n (2 bytes) ]
```

Moves the integer specified by the 16-bit number (platform-specific-endianness) `n` into register `reg`.

##### `OP_MOV_BOOL`

**Structure:**

```
[ code (1 byte) ] [ n (1 byte) ] [ reg (1 bytes) ] [ (unused 1 byte) ]
```

Moves the boolean specified by the 8-bit number `n` into register `reg`.

##### `OP_LOAD_CONST`

**Structure:**

```
[ code (1 byte) ] [ reg (1 byte) ] [ n (2 bytes) ]
```

Moves the constant specified by the 16-bit number (with endianness specified by the running platform) `n` into register `reg`.

#### Binary opcodes

These are the opcodes `OP_MUL`, `OP_DIV`, `OP_ADD`, `OP_SUB`, `OP_MOD`, `OP_EQ`, `OP_NEQ`, `OP_LT`, `OP_GT`, `OP_LEQ`, `OP_GEQ`. They have the following structure:

```
[ code (1 byte) ] [ left (1 byte) ] [ right (1 byte) ] [ result (1 byte) ]
```

They perform a binary operation specified by `code` on the registers specified by `left` and `right`, and stores the result into the register specified by `result`.

##### Binary-assign opcodes

These are the opcodes `OP_MUL_ASG`, `OP_DIV_ASG`, `OP_ADD_ASG`, `OP_SUB_ASG`, `OP_MOD_ASG`. They have the following structure:

```
[ code (1 byte) ] [ reg (1 byte) ] [ local (1 byte) ] [ (unused 1 byte) ]
```

They perform a binary operation specified by `code` on the local variable specified by `local` and register specified by `reg`, and stores the result into the local variable.

#### Unary opcodes

These are the opcodes `OP_NOT`. They have the following structure:

```
[ code (1 byte) ] [ reg (1 byte) ] [ (unused 2 bytes) ]
```

They perform the unary operation specified by `code` directly on the register specified by `reg`.

#### `OP_MOV_REG_LOCAL` and `OP_MOV_LOCAL_REG`

**Structure:**

```
[ code (1 byte) ] [ reg (1 byte) ] [ local (1 byte) ] [ (unused 1 byte) ]
```

The `OP_MOV_REG_LOCAL` operation copies the value in register `reg` to the local `local`.

The `OP_MOV_LOCAL_REG` operation copies the value in local `local` to the register `reg`.

#### `OP_PRINT`

**Structure:**

```
[ code (1 byte) ] [ reg (1 byte) ] [ (unused 2 bytes) ]
```

Prints the value in register `reg`.

#### Jump opcodes

##### `OP_JIF` and `OP_JNIF`

**Structure:**

```
[ code (1 byte) ] [ reg (1 byte) ] [ address (2 bytes) ]
```

The `OP_JIF` operation adds the 16-bit value  (platform-specific-endianness) `address`, multiplied by 4 to virtual machine address (i.e. jumps to it) if the value in register `reg` is truthy.

The `OP_JNIF` does the same thing, except only if the value is not truthy.

##### `OP_JREL` and `OP_JRELB`

**Structure:**

```
[ code (1 byte) ] [ (unused 1 byte) ] [ address (2 bytes) ]
```

The `OP_JREL` operation adds the 16-bit value  (platform-specific-endianness) `address`, multiplied by 4 to virtual machine address (i.e. jumps forwards to it).

The `OP_JREL` operation subtracts the 16-bit value  (platform-specific-endianness) `address`, multiplied by 4 to virtual machine address (i.e. jumps back to it).

#### Function-related opcodes

##### `OP_PUSH_ARG`

**Structure:**

```
[ code (1 byte) ] [ reg (1 byte) ] [ (unused 2 bytes) ]
```

Pushes the value in the register `reg` to the call argument stack.

##### `OP_CALL`

**Structure:**

```
[ code (1 byte) ] [ reg (1 byte) ] [ idx (2 bytes) ]
```

Calls the function specified by the 16-bit index  (platform-specific-endianness) `idx`, and sets its return value to the register `reg`.

##### `OP_RET_LOCAL`, `OP_RET`

**Structure:**

```
[ code (1 byte) ] [ loc (1 byte) ] [ (unused 2 bytes) ]
```

The `OP_RET_LOCAL` operation returns the local `loc`.

The `OP_RET` operation returns the register `loc`.

##### `OP_RET_NULL`

Returns a null value.

#### Array-related opcodes

##### `OP_ARRAY_NEW`

**Structure:**

```
[ code (1 byte) ] [ reg (1 byte) ] [ n (2 bytes) ]
```

Allocates an array of capacity specified by the 16-bit number (platform-specific-endianness) `n` into register `reg`.

##### `OP_ARRAY_PUSH`

**Structure:**

```
[ code (1 byte) ] [ array (1 byte) ] [ value (1 byte) ] [ (unused 1 byte) ]
```

Pushes the value in the register `value` to the array in the register `array`. Does nothing if the register isn't an array.

##### `OP_IDX_GET`

**Structure:**

```
[ code (1 byte) ] [ col (1 byte) ] [ idx (1 byte) ] [ result (1 byte) ]
```

Gets the value of the collection `col` specified by the index value in the register `idx`, and puts the value into the register `result`.

##### `OP_IDX_SET`

**Structure:**

```
[ code (1 byte) ] [ col (1 byte) ] [ idx (1 byte) ] [ value (1 byte) ]
```

Sets the value of the collection `col` specified by the index value in the register `idx` to the value in the register `value`.

### Function calls

### Constants

For primitive values (strings) which can't be expressed by a simple operation, the VM supports constants. They are stored in a *constant cache* in the thread-local storage, and they can be loaded through the `OP_LOAD_CONST` instruction.

Once loaded, they cannot be destroyed in the aulang language (their reference count is always greater than one). Only when the thread-local storage is deleted do the constants get destroyed.

Note that constants are an interpreter implementation detail, the C compiler doesn't use VM constants.

### Modules

Every file imported by aulang (including the main file) is stored in a program structure (the `au_program_data` object).

#### Imports and exports

In interpreter mode, aulang imports files in runtime rather than parsing time. Imported modules are referenced as indices to an imported file array, internal to the **importer**. We'll call the imported module's index relative to the *importer*, the *relative module index*.

When a file is parsed, if it calls an external module's function, the parser records it as a "virtual function". The virtual function is an object which has a name, the number of arguments it takes and the *relative module index* of the module. This *virtual imported function* is blank, it doesn't know which external function it points to, only what the external function looks like.

On runtime, when the virtual machine imports the module, it will store a reference to the module in the `au_vm_thread_local` object. The *relative module index* of the imported module is used to store the pointer to the corresponding actual module function, plus the pointer to the module structure, into the *virtual imported function* that refers to it.

**Invariant:** a pointer to an external module must not be moved or freed, which is why imported modules are stored in a linked list in the `au_vm_thread_local` object instead of an array.

## C compiler details
